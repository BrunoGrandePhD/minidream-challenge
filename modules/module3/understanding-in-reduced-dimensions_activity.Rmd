---
title: "Understanding data in reduced dimensions"
author: "Diana Murray"
date: "June 25, 2018"
output: html_notebook
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

set_basepath <- function(type = c("data", "R")) {
  if (stringr::str_length(Sys.which("rstudio-server"))) {
    file.path("/home/shared", type)
  } else {
    here::here(type)
  }
}

data_dir <- set_basepath("data")
scripts_dir <- set_basepath("R")
source(file.path(scripts_dir, "submission_helpers.R"))
```

# About this activity

...

---

# Loading and inspecting the data

Run the chunk below to pre-load and format some data that you'll be using for the activity below. Feel free to review the individual steps (**hint:** they're similar to the transformations we applied in Module 1), but otherwise we'll jump right into inspecting and working with the data!

```{r}
load(file.path(data_dir, "pson_expr_tpm_df.RData"))
load(file.path(data_dir, "pson_expr_gene_info.RData"))
load(file.path(data_dir, "pson_motility_tidy_df.RData"))

pson_pca_inputs_file <- file.path(data_dir, "pson_pca_inputs.RData")
if (!file.exists(pson_pca_inputs_file)) {
  pson_expr_tpm_df2 <- merge(x = gene_df, y = pson_expr_tpm_df, 
                      by.x = "gene_id", by.y = "gene_id")
  pson_tpm_mat <- as.matrix(pson_expr_tpm_df2[, -c(1:5)])
  rownames(pson_tpm_mat) <- pson_expr_tpm_df2$symbol
  pson_logtpm_mat <- log2(1 + pson_tpm_mat)
  pson_pca_mat<-t(pson_logtpm_mat)
  save(list = c("pson_pca_mat", "pson_logtpm_mat"), 
       file = pson_pca_inputs_file)
} else {
  load(pson_pca_inputs_file)
}
```

Check out `pson_expr_tpm_df`:

```{r}
# How do you see what is included in this data frame? Run the command. 
str(pson_expr_tpm_df) # TODO: DELETE BEFORE ACTIVITY
```

```{r}
# What are the sample names in `pson_expr_tpm_df`?
colnames(pson_expr_tpm_df)[-1] # TODO: DELETE BEFORE ACTIVITY

# How are genes identified?
pson_expr_tpm_df$gene_id[1:5] # TODO: DELETE BEFORE ACTIVITY
```

```{r}
# Andrew taught us many ways to inspect the data. Try this one.
View(pson_expr_tpm_df[1:1000, ]) # only view the first 1000 rows so we don't
                                 # make your browser too unhappy...
```

As you learned, the gene IDs are not very informative — they come from a database called **Ensembl**. More commonly, we would use the **Hugo gene symbols** (https://www.genenames.org/). These are the gene names you are more used to seeing (MYC, BRCA1, etc). We have this information stored in another file.

Check out the first few rows of `gene_df`:

```{r}
# Run the command to view the first 6 rows of `gene_df`
head(gene_df) # TODO: DELETE BEFORE ACTIVITY
```

We now have a new variable called `pson_pca_mat` that we'll use for the examples below. Take a look at the first few rows and columns of this matrix, and try to figure out what changes were made to go from `pson_expr_tpm_df` and `gene_df` to what you see. Compare to `pson_logtpm_mat` and see what else is different.

```{r}
# Take a look at the first few rows and columns of `pson_pca_mat`
pson_pca_mat[1:5, 1:5] # TODO: DELETE BEFORE ACTIVITY

# Take a look at the first few rows and columns of `pson_logtpm_mat`
pson_logtpm_mat[1:5, 1:5] # TODO: DELETE BEFORE ACTIVITY
```

Besides any normalization (e.g., "log" of expression values), translation (changing gene IDs to symbols), or format conversion (data frame to matrix), we've also **transposed** or rotated the data such that genes are now represented by columns and samples by rows. More on why we did this next!

---

# Getting started with PCA with PS-ON cell line data

We will use the function **`prcomp()`** to run the principal component analysis (PCA) algorithm. We're interested in checking out the variability and similarity of samples (cell lines) in our data based on their gene expression patterns. To do this, we need to give `prcomp()` a matrix as where the samples are the *rows*, and the features (transcript counts) are the *columns*. If we hadn't transposed, PCA would still work — but it would instead be telling us about the relationship *between* genes.

## Calculating PCA

We want to make sure that we can connect our expression data to motility measurements. I happen to know that for one sample in `pson_pca_mat`, we're missing motility data (I cheating a bit and checked in advance, but it makes life easier given our time constraints).

```{r}
# let's locate and remove the sample with no motility measurement data
pca_mat_samples <- rownames(pson_pca_mat)
missing_row <- which(!(pca_mat_samples %in% pson_motil_tidy_df$sample))
missing_row
pson_pca_mat <- pson_pca_mat[-missing_row, ]   
```

As described in our lecture, there are two additional things for us to consider:

+ 1. The data should be mean-centered around 0. 
+ 2. The data should be scaled so that the standard deviation for each gene is 1. 

Our features have the same units, and it is often the case that they are not scaled; this is somewhat subjective. "prcomp()" automatically mean-centers the data for us. Scaling is up to us.

```{r}
pson_pca <- prcomp(pson_pca_mat, scale = FALSE)
```

Exciting, right?  But now we can get to our exploratory analysis.  What goodies does PCA_PSON hold for us?

```{r}
names(pson_pca)
```

We discussed these in the lecture. To summarize:

+ `sdev`: The standard deviation of the principal components
+ `rotation`: The matrix of feature loadings (weights)
+ `center`: The feature means that prcomp() subtracted from each feature
+ `scale`: The feature standard deviations used in scaling
+ `x`: Coordinates of the cell lines projected onto the principal components

```{r}
dim(pson_pca$sdev)
dim(pson_pca$rotation)
dim(pson_pca$center)
dim(pson_pca$scale)
dim(pson_pca$x)
```

Are these dimensions what you would expect?

```{r}
pson_pca$rotation[1:5, 1:5]
```

```{r}
pson_pca$x[1:5, 1:5]
```


```{r}
length(pson_pca$sdev)
length(pson_pca$center)
length(pson_pca$scale)
```

Check the values out! Why does scale have length 1?

In this module, we are interested in "sdev," to calculate the variation explained by the principal components, and "x," which provides the coordinates of the samples (cell lines) onto the principal components.

Has PCA reduced the dimensionality of our data? Let's examine the importance of the principal components by ploting the percentage of variance explained. 

```{r}
pve <- 100 * pson_pca$sdev^2 / sum(pson_pca$sdev^2)

par(mfrow = c(1, 2))

plot(pve,
  type = "o",
  ylab = "PVE", xlab = "Principal Component", col = "blue"
)

plot(cumsum(pve),
  type = "o",
  ylab = "Cumulative PVE", xlab = "Principal Component", col = "brown3"
)
```

## Visualizing patterns and groups with PCA

The first two PCs account for a lot of the variance, > 40%.  The first 10 PCs account for almost all of the variance.  Let's see if the first two PCs, PC1 and PC2, reveal any patterns in our data.

```{r}
plot(pson_pca$x[, 1:2],
  pch = 19, cex = 0.8,
  xlab = "Projection onto PC1", ylab = "Projection onto PC2"
)
```

Each point gives the coordinates of a sample/cell line in PC space.
It's a nice pattern with some potential.  Does is have meaning for our data set?
Let's color the points by cell line type and diagnosis.

```{r}
cell_speeds_df <- subset(pson_motil_tidy_df, summary_metric == "speed_um_hr")

names(cell_speeds_df)
```

We will color by "`cellLine`" and "`diagnosis`", and it is possible to explore other relationships as well.

Here is a simple function for coloring points by type:

```{r}
color_by_type <- function(vec) {
  nn <- length(unique(vec))
  cols <- viridisLite::viridis(nn)
  # cols <- rainbow(nn, start = 0, end = max(1, nn - 1) / nn)

  return(cols[as.numeric(as.factor(vec))])
}
```

```{r}
colors <- color_by_type(unique(cell_speeds_df$diagnosis))
diag <- unique(cell_speeds_df$diagnosis)
plot(pson_pca$x[, c(1, 2)],
  col = scales::alpha(color_by_type(cell_speeds_df$diagnosis), 0.8),
  main = "Diagnosis", pch = 19, cex = 0.8
)

legend("bottomright", fill = colors, legend = diag, cex = 0.8)
```

```{r}
colors <- color_by_type(unique(cell_speeds_df$cellLine))
cell <- unique(cell_speeds_df$cellLine)
plot(pson_pca$x[, c(1, 2)],
  col = scales::alpha(color_by_type(cell_speeds_df$cellLine), 0.8),
  main = "Cell Line", pch = 19, cex = 0.8
)

legend("bottomright", fill = colors, legend = cell, cex = 0.8)
```

```{r}
colors <- color_by_type(unique(cell_speeds_df$cellLine))
cell <- unique(cell_speeds_df$cellLine)
plot(pson_pca$x[, c(1, 2)],
  main = "Cell Line", pch = 19, cex = 0
)
text(pson_pca$x[, c(1, 2)], 
     labels = gsub(" Cancer", "", cell_speeds_df$diagnosis),
     col = scales::alpha(color_by_type(cell_speeds_df$cellLine), 0.8),
     pos = 2, offset = 0, cex = 0.8)

legend("bottomright", fill = colors, legend = cell, cex = 0.8)
```

We see a nice pattern in the data:  In (PC1, PC2) space, the cell lines are nicely separated.
Note that the two breast cancer cell lines do NOT cluster together.

We can perform additional principal components analyses on cell line specific data. 

T-47D and MDA-MB-231, two breast cancer cell lines form distinct well-separated groups.

Why might this be?

---

# PCA with patient data from TCGA

## Load the data

```{r}
load(file.path(data_dir, "tcga_brca_expr_gene_info.RData"))
load(file.path(data_dir, "tcga_brca_expr_norm_df.RData"))
load(file.path(data_dir, "tcga_brca_clinical_df.RData"))

x1 <- names(brca_expr_norm_df)[-1]
x2 <- brca_clinical_df[["bcr_patient_barcode"]]
sample.names <- intersect(x1, x2)
sample.names <- sort(sample.names)

I <- match(sample.names, names(brca_expr_norm_df))
I <- c(1, I)
brca_expr_norm_df <- brca_expr_norm_df[, I]

I <- match(sample.names, brca_clinical_df[["bcr_patient_barcode"]])
brca_clinical_df <- brca_clinical_df[I, ]

brca_expr_norm_df2 <- merge(x = gene_df,
                            y = brca_expr_norm_df,
                            by.x = "gene_id",
                            by.y = "gene_id")


brca_expr_mat <- as.matrix(brca_expr_norm_df2[, -c(1:5)])
rownames(brca_expr_mat) <- brca_expr_norm_df2$symbol

brca_log_mat <- log2(1 + brca_expr_mat)
brca_pca_mat <- t(brca_log_mat)
```


```{r}
brca_pca_mat[1:5, 1:5]
```

## Calculating PCA

Implementing the PCA algorithm in R is now straightforward.

```{r}
brca_pca <- prcomp(brca_pca_mat)

dim(brca_pca$x)
brca_pca$x[1:5,1:5]
```

Let's look at the percent variance explained (or accounted for) by the principal components.

```{r}
pve <- 100 * brca_pca$sdev^2 / sum(brca_pca$sdev^2)
plot(pve, type = "o", ylab = "PVE", xlab = "Principal Component", col = "blue")
```

Because we have so many PCs (the number of samples - 1 = 1082), we'll consider only the first 100.

```{r}
par(mfrow = c(1, 2))

plot(pve, type = "o", ylab = "PVE", xlab = "Principal Component", 
     xlim = c(1, 100), col = "blue")

plot(cumsum(pve), type = "o", ylab = "Cumulative PVE", 
     xlab = "Principal Component", xlim = c(1, 100), col = "brown3")
```

```{r}
print("PVE")
round(pve[1:10], 0)

print("Cumulative PVE")
round(cumsum(pve)[1:10], 0)
```

In contrast to the PSON PCA where the first two PCs account for 40% of the variance, the first two PCs for the TCGA brca analysis account for only 20% of the variance. However, for large microarray data sets, this is considered pretty good, and often PC1 and PC2 carry a fair amount of useful information.

```{r}
plot(brca_pca$x[, c(1, 2)], cex = 0.8)
```

We see roughly two clusters.  Do these have biologial meaning?  What clinical information do we have on the TCGA brca samples?


```{r}
names(brca_clinical_df)
```


Ok, so we have quite a lot of information.  Let's consider estrogen receptor (ER) status. We considered this in the lecture for a different brca set.   I am including lines to pull the progeterone receptor (PR) and the receptor tyrosine kinase erbB-2 (HER2) for your examination later.

```{r}
ER_status <-brca_clinical_df$breast_carcinoma_estrogen_receptor_status
```


What values are encompassed by estrogen receptor status in the brca clinical features data frame?

```{r}
unique_status <- unique(ER_status)
for (i in 1:length(unique_status)) {
  print(c(unique_status[i], length(ER_status[ER_status == unique_status[i]])))
}

# another way to do this is with the `table()` function!
table(ER_status)
```

## Visualizing patterns and groups with PCA

We'll color the samples in the PC1/PC2 project plot according to ER status.

```{r}
colors <- color_by_type(unique(ER_status))
diag <- unique(ER_status)
plot(brca_pca$x[, c(1, 2)],
  col = scales::alpha(color_by_type(ER_status), 0.7),
  main = "ER status", pch = 19, cex = 0.8
)

legend("bottomleft", fill = colors, legend = diag, cex = 0.8)
```

---

# mini-DREAM Challenge  

**QUESTION:** ... ?

1) do PCA for PR status and HER2 status, 2) describe for which plots PC1 and PC2 are informative, and 3) do PC1 and PC2 hold information about triple negative?


```{r}
PR_status <- brca_clinical_df$breast_carcinoma_progesterone_receptor_status
HER2_status <- brca_clinical_df$lab_proc_her2_neu_immunohistochemistry_receptor_status
```

```{r}
colors <- color_by_type(unique(PR_status))
diag <- unique(PR_status)
plot(brca_pca$x[, c(1, 2)],
  col = scales::alpha(color_by_type(PR_status), 0.7),
  main = "PR status", pch = 19, cex = 0.8
)

legend("bottomleft", fill = colors, legend = diag, cex = 0.8)
```

```{r}
colors <- scales::alpha(color_by_type(unique(HER2_status)))
diag <- unique(HER2_status)
plot(brca_pca$x[, c(1, 2)],
  col = scales::alpha(color_by_type(HER2_status), 0.7),
  main = "HER2 status", pch = 19, cex = 0.8
)

legend("bottomleft", fill = colors, legend = diag, cex = 0.8)
```




## Submitting the prediction

You're now ready to submit the prediction. Just run the chunk below, a file with your prediction will be uploaded to Synapse and submitted to the challenge. You'll be able to see the results of your prediction on the mini-DREAM scoreboards, with the submission ID that gets printed below.

```{r}
library(synapser)

# If you didn't submit an answer for a previous module, remove the '#'s
# on the next 2 lines and enter your Synapse username and password
# before running this chunk.
# synLogin('my_synapse_username', 'my_synapse_password',
#          rememberMe = TRUE, silent = TRUE)

# If you submitted for Module 0, this should work.
# synLogin(silent = TRUE)
# submission <- submit_module_answers(module = 3)
```

Congrats — you’ve reached the end of **Module 3**! You can now return to the **mini-DREAM Challenge** site on Synapse.

---

